---
aliases: [AI, Artificial Intelligence]
---

```java
继承树：public this super [[基本]]，[[Other]] has [B, C, D] throw [Super向上回溯(限定范围)/Any子元素(具体处理)]
继承树：<权限> <修饰符>this super A has B throw C
关键字：用典、意象、标签。相似（线索：近义词、同义词、反义词等等）
```

> 我们始终践行的实用主义是，简单和优雅。（简单意味着更快更好。）
> 我希望元素的概念可以泛化与多样性。它是自由的且具有多样性的结构。

> 函数文本
> 最小可复用文本句段是函数文本，类似tw条目。


# 标题：水（元素 - 基本）

**引用**，出现在文中，使用wiki链接。


- 通过继承树，我大概可以实现网状结构和树状结果。
- 通过关键字，我可以大概摘要出文件内容
- 通过四种抽象模型，可以演化出丰富与多样性。
- 通过继承树，我可以使用搜索功能检索到任何类别的元素，包括访问权限、深度1的检索等等。


## 符号定义

1. 空：基本。事物其本身就是它；
2. &：组合。与，连接组合事物；
3. @：实例。 at；
4. ?：多态。问号，状态不明。
5. 权限：`<public><default><private>`，公开、默认、私有。不写为默认`<default>`
6. 关键字：相关关系，类相互之间的关联，在类的内部用典吧，典与典之间勾连
7. this代指当前文件
8. as代指多态的基本参考元素
9. super代指父类
10. has代指当前类含有子类列表
11. throw 代指父元素限定范围，子元素实际处理。


## 模型

关于多继承，排序依次从 最相关 到 最不相关 。

- 广度：多态，?this as [[参考元素]]
- 深度：继承，super or has，
- 复杂度：组合，&this complex A，B， ...
- 实现：实例，@this ，语义概念与实例的映射。语义概念的不断发展。

其中为了方便理解，大致可以用空间思维概括：其中多态第一维，继承第二维，复杂度第三维，实例第四维。

通过这种继承树表达式和搜索工具（普通或正则）的结合，可以任意检索你想找到的一组相关元素。


多继承（Multiple inheritance），即一个子类可以有多个父类，它继承了多个父类的特性。多继承可以看作是单继承的扩展。所谓多继承是指派生类具有多个基类，派生类与每个基类之间的关系仍可看作是一个单继承。（也就说番茄既属于水果也属于蔬菜）

对于程序设计来说：菱形继承，它会造成数据冗余和二义性的问题。水果，香蕉，橘子，水果沙拉。


### 推导式

公式：B ∈ A = this{B} super A
解释，元素B属于元素A 等价于 元素B的父类是元素A。

公式：存在 this->{B，C} super A = ?this->{B} as B super A OR ?this->{C} as B super A
解释，B和C的父类是A，等价于 B 和 C 是同一族，同一广度。这意味着基本元素（类）概念唯一。文件有类别，文件可合并，文件可继承，最后映射到实例。

## 定义权限

- `<public>`：任何人都可阅读查看。
- `<default>`：仅某一个群体或某个人比如核心家庭。权限不填留空，默认为`<default>`
- `<private>`：只能自己保护好，仅属于自己，这也是在保护他人，因为有些事情和信息只能自己讲给自己，比如自己身上的组织不能给别人。会发生免疫反应的。有些东西是不适合拿去分享的。比如你的观点。这些例子举不胜数。